/*
===============================================================================
 Name        : main.c
 Author      : 
 Version     :
 Copyright   : Copyright (C) 
 Description : main definition
===============================================================================
*/
// Es la misma aplicación anterior con el agregado de que el match 1 activa el pin correspondiente P1.29 para toggle

#ifdef __USE_CMSIS
#include "LPC17xx.h"
#endif

#include "Aplicacion.h"
// Variable to store CRP value in. Will be placed automatically
// by the linker when "Enable Code Read Protect" selected.
// See crp.h header for more information
__CRP const unsigned int CRP_WORD = CRP_NO_CRP ;

// TODO: insert other include files here
// TODO: insert other definitions and declarations here

//-----------------------------------------------------------------------------
// Programa principal
//-----------------------------------------------------------------------------


const uint8_t SystemFont5x7[]  = {
    0x0, 0x0, // Font size in bytes (uint16_t)
    	      // Size of zero indicates fixed width font. Actual length is width * height
    0x05,     // Width
    0x07, 	  // Height
    0x20,     // First char
    0x7f,     // Char count

    // Fixed width. Char width table not used

    // Font data
    0x00, 0x00, 0x00, 0x00, 0x00,// (space)
    0x00, 0x00, 0x5F, 0x00, 0x00,// !
	0x00, 0x07, 0x00, 0x07, 0x00,// "
	0x14, 0x7F, 0x14, 0x7F, 0x14,// #
	0x24, 0x2A, 0x7F, 0x2A, 0x12,// $
	0x23, 0x13, 0x08, 0x64, 0x62,// %
	0x36, 0x49, 0x55, 0x22, 0x50,// &
	0x00, 0x05, 0x03, 0x00, 0x00,// '
	0x00, 0x1C, 0x22, 0x41, 0x00,// (
	0x00, 0x41, 0x22, 0x1C, 0x00,// )
	0x7F, 0x7F, 0x7F, 0x7F, 0x7F,//0x08, 0x2A, 0x1C, 0x2A, 0x08,// *
	0x08, 0x08, 0x3E, 0x08, 0x08,// +
	0x00, 0x50, 0x30, 0x00, 0x00,// ,
	0x08, 0x08, 0x08, 0x08, 0x08,// -
	0x00, 0x60, 0x60, 0x00, 0x00,// .
	0x20, 0x10, 0x08, 0x04, 0x02,// /
	0x3E, 0x51, 0x49, 0x45, 0x3E,// 0
	0x00, 0x42, 0x7F, 0x40, 0x00,// 1
	0x42, 0x61, 0x51, 0x49, 0x46,// 2
	0x21, 0x41, 0x45, 0x4B, 0x31,// 3
	0x18, 0x14, 0x12, 0x7F, 0x10,// 4
	0x27, 0x45, 0x45, 0x45, 0x39,// 5
	0x3C, 0x4A, 0x49, 0x49, 0x30,// 6
	0x01, 0x71, 0x09, 0x05, 0x03,// 7
	0x36, 0x49, 0x49, 0x49, 0x36,// 8
	0x06, 0x49, 0x49, 0x29, 0x1E,// 9
	0x00, 0x36, 0x36, 0x00, 0x00,// :
	0x00, 0x56, 0x36, 0x00, 0x00,// ;
	0x00, 0x08, 0x14, 0x22, 0x41,// <
	0x14, 0x14, 0x14, 0x14, 0x14,// =
	0x41, 0x22, 0x14, 0x08, 0x00,// >
	0x02, 0x01, 0x51, 0x09, 0x06,// ?
	0x32, 0x49, 0x79, 0x41, 0x3E,// @
	0x7E, 0x11, 0x11, 0x11, 0x7E,// A
	0x7F, 0x49, 0x49, 0x49, 0x36,// B
	0x3E, 0x41, 0x41, 0x41, 0x22,// C
	0x7F, 0x41, 0x41, 0x22, 0x1C,// D
	0x7F, 0x49, 0x49, 0x49, 0x41,// E
	0x7F, 0x09, 0x09, 0x01, 0x01,// F
	0x3E, 0x41, 0x41, 0x51, 0x32,// G
	0x7F, 0x08, 0x08, 0x08, 0x7F,// H
	0x00, 0x41, 0x7F, 0x41, 0x00,// I
	0x20, 0x40, 0x41, 0x3F, 0x01,// J
	0x7F, 0x08, 0x14, 0x22, 0x41,// K
	0x7F, 0x40, 0x40, 0x40, 0x40,// L
	0x7F, 0x02, 0x04, 0x02, 0x7F,// M
	0x7F, 0x04, 0x08, 0x10, 0x7F,// N
	0x3E, 0x41, 0x41, 0x41, 0x3E,// O
	0x7F, 0x09, 0x09, 0x09, 0x06,// P
	0x3E, 0x41, 0x51, 0x21, 0x5E,// Q
	0x7F, 0x09, 0x19, 0x29, 0x46,// R
	0x46, 0x49, 0x49, 0x49, 0x31,// S
	0x01, 0x01, 0x7F, 0x01, 0x01,// T
	0x3F, 0x40, 0x40, 0x40, 0x3F,// U
	0x1F, 0x20, 0x40, 0x20, 0x1F,// V
	0x7F, 0x20, 0x18, 0x20, 0x7F,// W
	0x63, 0x14, 0x08, 0x14, 0x63,// X
	0x03, 0x04, 0x78, 0x04, 0x03,// Y
	0x61, 0x51, 0x49, 0x45, 0x43,// Z
	0x00, 0x00, 0x7F, 0x41, 0x41,// [
	0x02, 0x04, 0x08, 0x10, 0x20,// "\"
	0x41, 0x41, 0x7F, 0x00, 0x00,// ]
	0x04, 0x02, 0x01, 0x02, 0x04,// ^
	0x40, 0x40, 0x40, 0x40, 0x40,// _
	0x00, 0x01, 0x02, 0x04, 0x00,// `
	0x20, 0x54, 0x54, 0x54, 0x78,// a
	0x7F, 0x48, 0x44, 0x44, 0x38,// b
	0x38, 0x44, 0x44, 0x44, 0x20,// c
	0x38, 0x44, 0x44, 0x48, 0x7F,// d
	0x38, 0x54, 0x54, 0x54, 0x18,// e
	0x08, 0x7E, 0x09, 0x01, 0x02,// f
	0x08, 0x14, 0x54, 0x54, 0x3C,// g
	0x7F, 0x08, 0x04, 0x04, 0x78,// h
	0x00, 0x44, 0x7D, 0x40, 0x00,// i
	0x20, 0x40, 0x44, 0x3D, 0x00,// j
	0x00, 0x7F, 0x10, 0x28, 0x44,// k
	0x00, 0x41, 0x7F, 0x40, 0x00,// l
	0x7C, 0x04, 0x18, 0x04, 0x78,// m
	0x7C, 0x08, 0x04, 0x04, 0x78,// n
	0x38, 0x44, 0x44, 0x44, 0x38,// o
	0x7C, 0x14, 0x14, 0x14, 0x08,// p
	0x08, 0x14, 0x14, 0x18, 0x7C,// q
	0x7C, 0x08, 0x04, 0x04, 0x08,// r
	0x48, 0x54, 0x54, 0x54, 0x20,// s
	0x04, 0x3F, 0x44, 0x40, 0x20,// t
	0x3C, 0x40, 0x40, 0x20, 0x7C,// u
	0x1C, 0x20, 0x40, 0x20, 0x1C,// v
	0x3C, 0x40, 0x30, 0x40, 0x3C,// w
	0x44, 0x28, 0x10, 0x28, 0x44,// x
	0x0C, 0x50, 0x50, 0x50, 0x3C,// y
	0x44, 0x64, 0x54, 0x4C, 0x44,// z
	0x00, 0x08, 0x36, 0x41, 0x00,// {
	0x00, 0x00, 0x7F, 0x00, 0x00,// |
	0x00, 0x41, 0x36, 0x08, 0x00,// }
	0x08, 0x08, 0x2A, 0x1C, 0x08,// ->
	0x08, 0x1C, 0x2A, 0x08, 0x08, // <-
//	0x00, 0x06, 0x09, 0x09, 0x06 //º
};

__RW uint8_t firstchar=0x20;	//variables que dependen de la tipografia
__RW uint8_t width=0x05;
__RW uint8_t offset=6;
__RW uint8_t flash=0;

//buffer de lo que se muestra en pantalla
__RW uint8_t bufferPantalla[MAXBUFFER]; //defino 100 caracteres maximo

//vector de estructuras donde se almacenan los mensajes
__RW Elemento Mensajes[25];
__RW uint8_t Leng=1; //longitud del vector, cuantos mensajes debe mostrar
__RW uint8_t Inicio=0; //indice que apunta al mensaje que se esta mostrando

__RW uint16_t indexInicio=0;	//indice desde el cual se muestra en pantalla
__RW uint16_t indexFin=MATRIXWIDTH;	//indice hasta el cual se muestra en pantalla, siempre difieren en MATRIXWIDTH
__RW uint16_t indexRestart;	//indica hasta que valor debe incrementarse indexFin
__RW uint8_t cambioDeIndice;	//avisa si se debe correr los indices
__RW uint8_t velocidadActual;	//velocidad del mensaje que se muestra
__RW uint8_t flag_flash;

__RW uint32_t TmrRunM[9];	//para maq de timers
__RW uint8_t EventosM;

__RW uint8_t Humestring[7]; 	//vectores globales que tienen las medidas de la temp y humedad
__RW uint8_t Tempstring[8];

__RW uint8_t flagLeerMensajeNuevo=0; //flag que indica si se debe leer un mensaje nuevo


//para 485
__RW uint8_t bufferuart3[TOPE];
__RW uint8_t inx_out3=0;
__RW uint8_t inx_in3=0;
__RW uint8_t enviando=0;
__RW uint8_t iniciar485=0;	//indica que se debe iniciar la transmision por 485
__RW uint8_t enviando485=0; //indica que se debe ir a buscar proximo paquete a enviar

__RW uint8_t cantbytes=0;
__RW uint8_t findeenvio=0;
__RW uint8_t id485=1;	//es el id de la esclava a la que se transmite, se va incrementando
__RW uint8_t actualizandodatos=1;	//indica que se esta actualizando temp y humedad
__RW uint8_t esperandoACK=0;	//indica si se esta esperando ack, si se recibe ack y no se esta esperando se ignora
__RW uint8_t enviarfindetx=0;	//indica que se debe enviar fin de transmision
__RW uint8_t indice=0;

int main(void) {
	


	InicializarKit ();						// Inicialización del Kit
	uint32_t delay;
	uint8_t lectura,cantlecturas=0;
	flag_flash=OFF;




	for(delay=0;delay<0x00ffffff;delay++); //delay de aprox 2 segs para dejar arrancar el DHT

	//Carga el primer elemento para empezar a mostrar algo
	Mensajes[0].arrayID[PROTOCOL_ID]= 1;
	strcpy(Mensajes[0].str,"J&J Fest!!!");
	Mensajes[0].vel = 8;
	Mensajes[0].Tipo_Elem=ELEMENTO_TEXTO;

	//busca mensaje para cargar el buffer
	get_message();


	InicTimer0();
	InicTimer1();
	InicTimer2(); //inicio base de tiempo de maquina para dht

	CambiarEstadoTE(TRANSMISION);

	while(1)
	{

		if(flash==OFF){

			if(flagLeerMensajeNuevo){
				ApagoTimers();//apago timers para no molestar en lectura de DHT
				lectura=DHT_Mde();

				if(!flagLeerMensajeNuevo){ //Entra una vez terminada la lectura del DHT
					get_message();
					ArrancoTimers();//vuelvo a encender timers con el buffer lleno
					cantlecturas++;
				}

				if(cantlecturas == 3 && actualizandodatos){ //cada 3 lecturas le actualizo datos a esclavos
					ActualizarDatos();
					cantlecturas=0;
				}
				else if(!actualizandodatos){
					cantlecturas=0;	//en caso de que se este transmitiendo informacion por el bus485, no se transmiten las actualizaciones
				}
			}
		}
		else if(flash==ON){

			if(flag_flash==OFF){
				apagarmatriz();

			}
			else if(flag_flash==ON){
				prendermatriz();


			}

		}



		if(iniciar485 && VencioTimer485){
			EnviarInicioTx();
			iniciar485=0;//para no volver a entrar
			EventosM=0;
		}




		//si se agoto el timer y se tiene que enviar el prox paquete, y el indice actual es menor al total
		//de paquetes (profilactico) y no se debe enviar fin de tx todavia
		if(VencioTimer485 && enviando485 && indice<Leng && !findeenvio){
			EnviarPaquete();
			enviando485=0;//para no volver a entrar
			EventosM=0;

		}

		//si se agoto el timer y se debe enviar el fin
		if(VencioTimer485 && findeenvio){

			EnviarFinTX();
			findeenvio=0;//para no volver a entrar
			EventosM=0;

		}


		if(VencioTimer485 && !enviando485 && !findeenvio && !iniciar485){
			CambiarEstadoTE(RECEPCION);	//paso a recepcion para esperar ack
			EventosM=0; //para no volver a entrar
			enviarfindetx=0;
		}


		if(VencioTimeOUT485){
			id485++;
			if(id485<=CANTESCLAVAS){
				iniciar485=1; //para arrancar nueva tx
				indice=0; //para q empiece desde el ppio
			}
			else{
				id485=1; //para preparar proxima tx
				CambiarEstadoTE(TRANSMISION);
				actualizandodatos=1;	//se activa de nuevo el bloque de envio de datos
			}
			EventosM=0; //para apagar timers
		}




	}



	return 0 ;

}







